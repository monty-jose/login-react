{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar validSSRModes = ['resolve', 'defer', 'boundary'];\n\nfunction asyncComponent(config) {\n  var name = config.name,\n      resolve = config.resolve,\n      _config$autoResolveES = config.autoResolveES2015Default,\n      autoResolveES2015Default = _config$autoResolveES === undefined ? true : _config$autoResolveES,\n      _config$serverMode = config.serverMode,\n      serverMode = _config$serverMode === undefined ? 'resolve' : _config$serverMode,\n      LoadingComponent = config.LoadingComponent,\n      ErrorComponent = config.ErrorComponent;\n\n  if (validSSRModes.indexOf(serverMode) === -1) {\n    throw new Error('Invalid serverMode provided to asyncComponent');\n  }\n\n  var env = ['node', 'browser'].indexOf(config.env) > -1 ? config.env : typeof window === 'undefined' ? 'node' : 'browser';\n  var sharedState = {\n    // A unique id we will assign to our async component which is especially\n    // useful when rehydrating server side rendered async components.\n    id: null,\n    // This will be use to hold the resolved module allowing sharing across\n    // instances.\n    // NOTE: When using React Hot Loader this reference will become null.\n    module: null,\n    // If an error occurred during a resolution it will be stored here.\n    error: null,\n    // Allows us to share the resolver promise across instances.\n    resolver: null // Takes the given module and if it has a \".default\" the \".default\" will\n    // be returned. i.e. handy when you could be dealing with es6 imports.\n\n  };\n\n  var es6Resolve = function es6Resolve(x) {\n    return autoResolveES2015Default && x != null && (typeof x === 'function' || (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object') && x.default ? x.default : x;\n  };\n\n  var getResolver = function getResolver() {\n    if (sharedState.resolver == null) {\n      try {\n        // Wrap whatever the user returns in Promise.resolve to ensure a Promise\n        // is always returned.\n        var resolver = resolve();\n        sharedState.resolver = Promise.resolve(resolver);\n      } catch (err) {\n        sharedState.resolver = Promise.reject(err);\n      }\n    }\n\n    return sharedState.resolver;\n  };\n\n  var AsyncComponent = function (_React$Component) {\n    _inherits(AsyncComponent, _React$Component);\n\n    function AsyncComponent(props, context) {\n      _classCallCheck(this, AsyncComponent); // We have to set the id in the constructor because a RHL seems\n      // to recycle the module and therefore the id closure will be null.\n      // We can't put it in componentWillMount as RHL hot swaps the new code\n      // so the mount call will not happen (but the ctor does).\n\n\n      var _this = _possibleConstructorReturn(this, (AsyncComponent.__proto__ || Object.getPrototypeOf(AsyncComponent)).call(this, props, context));\n\n      if (_this.context.asyncComponents != null && !sharedState.id) {\n        sharedState.id = _this.context.asyncComponents.getNextId();\n      }\n\n      return _this;\n    } // @see react-async-bootstrapper\n\n\n    _createClass(AsyncComponent, [{\n      key: 'asyncBootstrap',\n      value: function asyncBootstrap() {\n        var _this2 = this;\n\n        var _context = this.context,\n            asyncComponents = _context.asyncComponents,\n            asyncComponentsAncestor = _context.asyncComponentsAncestor;\n        var shouldRehydrate = asyncComponents.shouldRehydrate;\n\n        var doResolve = function doResolve() {\n          return _this2.resolveModule().then(function (module) {\n            return module !== undefined;\n          });\n        };\n\n        if (env === 'browser') {\n          return shouldRehydrate(sharedState.id) ? doResolve() : false;\n        } // node\n\n\n        var isChildOfBoundary = asyncComponentsAncestor != null && asyncComponentsAncestor.isBoundary;\n        return serverMode === 'defer' || isChildOfBoundary ? false : doResolve();\n      }\n    }, {\n      key: 'getChildContext',\n      value: function getChildContext() {\n        if (this.context.asyncComponents == null) {\n          return {\n            asyncComponentsAncestor: null\n          };\n        }\n\n        return {\n          asyncComponentsAncestor: {\n            isBoundary: serverMode === 'boundary'\n          }\n        };\n      }\n    }, {\n      key: 'componentWillMount',\n      value: function componentWillMount() {\n        this.setState({\n          module: sharedState.module\n        });\n\n        if (sharedState.error) {\n          this.registerErrorState(sharedState.error);\n        }\n      }\n    }, {\n      key: 'componentDidMount',\n      value: function componentDidMount() {\n        if (this.shouldResolve()) {\n          this.resolveModule();\n        }\n      }\n    }, {\n      key: 'shouldResolve',\n      value: function shouldResolve() {\n        return sharedState.module == null && sharedState.error == null && !this.resolving && typeof window !== 'undefined';\n      }\n    }, {\n      key: 'resolveModule',\n      value: function resolveModule() {\n        var _this3 = this;\n\n        this.resolving = true;\n        return getResolver().then(function (module) {\n          if (_this3.unmounted) {\n            return undefined;\n          }\n\n          if (_this3.context.asyncComponents != null) {\n            _this3.context.asyncComponents.resolved(sharedState.id);\n          }\n\n          sharedState.module = module;\n\n          if (env === 'browser') {\n            _this3.setState({\n              module: module\n            });\n          }\n\n          _this3.resolving = false;\n          return module;\n        }).catch(function (error) {\n          if (_this3.unmounted) {\n            return undefined;\n          }\n\n          if (env === 'node' || env === 'browser' && !ErrorComponent) {\n            // We will at least log the error so that user isn't completely\n            // unaware of an error occurring.\n            // eslint-disable-next-line no-console\n            console.warn('Failed to resolve asyncComponent'); // eslint-disable-next-line no-console\n\n            console.warn(error);\n          }\n\n          sharedState.error = error;\n\n          _this3.registerErrorState(error);\n\n          _this3.resolving = false;\n          return undefined;\n        });\n      }\n    }, {\n      key: 'componentWillUnmount',\n      value: function componentWillUnmount() {\n        this.unmounted = true;\n      }\n    }, {\n      key: 'registerErrorState',\n      value: function registerErrorState(error) {\n        var _this4 = this;\n\n        if (env === 'browser') {\n          setTimeout(function () {\n            if (!_this4.unmounted) {\n              _this4.setState({\n                error: error\n              });\n            }\n          }, 16);\n        }\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        var _state = this.state,\n            module = _state.module,\n            error = _state.error;\n\n        if (error) {\n          return ErrorComponent ? _react2.default.createElement(ErrorComponent, _extends({}, this.props, {\n            error: error\n          })) : null;\n        } // This is as workaround for React Hot Loader support.  When using\n        // RHL the local component reference will be killed by any change\n        // to the component, this will be our signal to know that we need to\n        // re-resolve it.\n\n\n        if (this.shouldResolve()) {\n          this.resolveModule();\n        }\n\n        var Component = es6Resolve(module);\n        return Component ? _react2.default.createElement(Component, this.props) : LoadingComponent ? _react2.default.createElement(LoadingComponent, this.props) : null;\n      }\n    }]);\n\n    return AsyncComponent;\n  }(_react2.default.Component);\n\n  AsyncComponent.displayName = name || 'AsyncComponent';\n  AsyncComponent.contextTypes = {\n    asyncComponentsAncestor: _propTypes2.default.shape({\n      isBoundary: _propTypes2.default.bool\n    }),\n    asyncComponents: _propTypes2.default.shape({\n      getNextId: _propTypes2.default.func.isRequired,\n      resolved: _propTypes2.default.func.isRequired,\n      shouldRehydrate: _propTypes2.default.func.isRequired\n    })\n  };\n  AsyncComponent.childContextTypes = {\n    asyncComponentsAncestor: _propTypes2.default.shape({\n      isBoundary: _propTypes2.default.bool\n    })\n  };\n  return AsyncComponent;\n}\n\nexports.default = asyncComponent;","map":null,"metadata":{},"sourceType":"script"}